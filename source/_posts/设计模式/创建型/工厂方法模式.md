---
title: 工厂方法模式
date: 2017-02-27 14:17:09
tags:
---
##工厂方法模式

解决的问题

    工厂一旦需要生产新产品就需要修改工厂类的方法逻辑，违背了“开放 - 关闭原则
    
伪代码
面试官接口，两个实现

    interface Interviewer {
        public function askQuestions();
    }
    
    class Developer implements Interviewer {
        public function askQuestions() {
            echo 'Asking about design patterns!';
        }
    }
    
    class CommunityExecutive implements Interviewer {
        public function askQuestions() {
            echo 'Asking about community building';
        }
    }
    
招聘经理：找个人去面试，然后问问题

    abstract class HiringManager {

        // Factory method
        abstract public function makeInterviewer() : Interviewer;
    
        public function takeInterview() {
            $interviewer = $this->makeInterviewer();
            $interviewer->askQuestions();
        }
    }

开发主管问开发者问题，市场主管问市场问题
    
    class DevelopmentManager extends HiringManager {
        public function makeInterviewer() : Interviewer {
            return new Developer();
        }
    }
    
    class MarketingManager extends HiringManager {
        public function makeInterviewer() : Interviewer {
            return new CommunityExecutive();
        }
    }
    
投入使用
    
    $devManager = new DevelopmentManager();
    $devManager->takeInterview(); // Output: Asking about design patterns
    
    $marketingManager = new MarketingManager();
    $marketingManager->takeInterview(); // Output: Asking about community building.
------------    
优点

    1. 工厂模式可以说是简单工厂模式的进一步抽象和拓展，
    在保留了简单工厂的封装优点的同时，让扩展变得简单，让继承变得可行，增加了多态性的体现。
    
缺点
    
    1. 添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；
    2. 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。
    3. 虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类；
    4. 一个具体工厂只能创建一种具体产品
