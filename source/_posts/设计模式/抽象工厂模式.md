---
title: 抽象工厂模式
date: 2017-02-27 14:28:08
tags:
---
##抽象工厂模式

解决的问题
     
    每个工厂只能创建一类产品

伪代码
首先我们需要若干种门

    interface Door {
        public function getDescription();
    }
    
    class WoodenDoor implements Door {
        public function getDescription() {
            echo 'I am a wooden door';
        }
    }
    
    class IronDoor implements Door {
        public function getDescription() {
            echo 'I am an iron door';
        }
    }
    
首先我们要若干老师傅

    interface DoorFittingExpert {
        public function getDescription();
    }
    
    class Welder implements DoorFittingExpert {
        public function getDescription() {
            echo 'I can only fit iron doors';
        }
    }
    
    class Carpenter implements DoorFittingExpert {
        public function getDescription() {
            echo 'I can only fit wooden doors';
        }
    }
    
好了，木门工厂有木门老师傅，铁门工厂有铁门老师傅
    
    interface DoorFactory {
        public function makeDoor() : Door;
        public function makeFittingExpert() : DoorFittingExpert;
    }
    
    // Wooden factory to return carpenter and wooden door
    class WoodenDoorFactory implements DoorFactory {
        public function makeDoor() : Door {
            return new WoodenDoor();
        }
    
        public function makeFittingExpert() : DoorFittingExpert{
            return new Carpenter();
        }
    }
    
    // Iron door factory to get iron door and the relevant fitting expert
    class IronDoorFactory implements DoorFactory {
        public function makeDoor() : Door {
            return new IronDoor();
        }
    
        public function makeFittingExpert() : DoorFittingExpert{
            return new Welder();
        }
    }
    
工厂启动    
    
    $woodenFactory = new WoodenDoorFactory();
    
    $door = $woodenFactory->makeDoor();
    $expert = $woodenFactory->makeFittingExpert();
    
    $door->getDescription();  // Output: I am a wooden door
    $expert->getDescription(); // Output: I can only fit wooden doors
    
    // Same for Iron Factory
    $ironFactory = new IronDoorFactory();
    
    $door = $ironFactory->makeDoor();
    $expert = $ironFactory->makeFittingExpert();
    
    $door->getDescription();  // Output: I am an iron door
    $expert->getDescription(); // Output: I can only fit iron doors
    
----
优点
    
    降低耦合
    抽象工厂模式将具体产品的创建延迟到具体工厂的子类中，这样将对象的创建封装起来，可以减少客户端与具体产品类之间的依赖，从而使系统耦合度低，这样更有利于后期的维护和扩展；

    更符合开-闭原则
    新增一种产品类时，只需要增加相应的具体产品类和相应的工厂子类即可

        简单工厂模式需要修改工厂类的判断逻辑

    符合单一职责原则
    每个具体工厂类只负责创建对应的产品

        简单工厂中的工厂类存在复杂的switch逻辑判断

    不使用静态工厂方法，可以形成基于继承的等级结构。

        简单工厂模式的工厂类使用静态工厂方法

缺点

    抽象工厂模式很难支持新种类产品的变化。
    这是因为抽象工厂接口中已经确定了可以被创建的产品集合，如果需要添加新产品，此时就必须去修改抽象工厂的接口，
    这样就涉及到抽象工厂类的以及所有子类的改变，这样也就违背了“开发——封闭”原则。